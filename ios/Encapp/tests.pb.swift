// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tests.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum DataValueType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case stringType // = 0
  case intType // = 1
  case floatType // = 2
  case longType // = 3

  init() {
    self = .stringType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stringType
    case 1: self = .intType
    case 2: self = .floatType
    case 3: self = .longType
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .stringType: return 0
    case .intType: return 1
    case .floatType: return 2
    case .longType: return 3
    }
  }

}

#if swift(>=4.2)

extension DataValueType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum PixFmt: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case yuv420P // = 0
  case yvu420P // = 1
  case nv12 // = 2
  case nv21 // = 3
  case rgba // = 4
  case p010Le // = 54

  init() {
    self = .yuv420P
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .yuv420P
    case 1: self = .yvu420P
    case 2: self = .nv12
    case 3: self = .nv21
    case 4: self = .rgba
    case 54: self = .p010Le
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .yuv420P: return 0
    case .yvu420P: return 1
    case .nv12: return 2
    case .nv21: return 3
    case .rgba: return 4
    case .p010Le: return 54
    }
  }

}

#if swift(>=4.2)

extension PixFmt: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Common {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var operation: String {
    get {return _operation ?? String()}
    set {_operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return self._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {self._operation = nil}

  var start: String {
    get {return _start ?? String()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  /// template or specific name for output file(s)
  /// Placeholder markers are [] 
  /// e.g. [common.id].[input.resolution].[configuration.bitrate]-[XXXX]
  /// X is a substitution marker for A random hex number (1-f)
  /// If not set the filename will be encapp_uuid
  var outputFilename: String {
    get {return _outputFilename ?? String()}
    set {_outputFilename = newValue}
  }
  /// Returns true if `outputFilename` has been explicitly set.
  var hasOutputFilename: Bool {return self._outputFilename != nil}
  /// Clears the value of `outputFilename`. Subsequent reads from it will return its default value.
  mutating func clearOutputFilename() {self._outputFilename = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: String? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _operation: String? = nil
  fileprivate var _start: String? = nil
  fileprivate var _outputFilename: String? = nil
}

struct Parameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var type: DataValueType {
    get {return _type ?? .stringType}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  /// For runtime purposes
  var framenum: Int64 {
    get {return _framenum ?? 0}
    set {_framenum = newValue}
  }
  /// Returns true if `framenum` has been explicitly set.
  var hasFramenum: Bool {return self._framenum != nil}
  /// Clears the value of `framenum`. Subsequent reads from it will return its default value.
  mutating func clearFramenum() {self._framenum = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: String? = nil
  fileprivate var _type: DataValueType? = nil
  fileprivate var _value: String? = nil
  fileprivate var _framenum: Int64? = nil
}

struct Input {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var filepath: String {
    get {return _filepath ?? String()}
    set {_filepath = newValue}
  }
  /// Returns true if `filepath` has been explicitly set.
  var hasFilepath: Bool {return self._filepath != nil}
  /// Clears the value of `filepath`. Subsequent reads from it will return its default value.
  mutating func clearFilepath() {self._filepath = nil}

  var resolution: String {
    get {return _resolution ?? String()}
    set {_resolution = newValue}
  }
  /// Returns true if `resolution` has been explicitly set.
  var hasResolution: Bool {return self._resolution != nil}
  /// Clears the value of `resolution`. Subsequent reads from it will return its default value.
  mutating func clearResolution() {self._resolution = nil}

  var pixFmt: PixFmt {
    get {return _pixFmt ?? .yuv420P}
    set {_pixFmt = newValue}
  }
  /// Returns true if `pixFmt` has been explicitly set.
  var hasPixFmt: Bool {return self._pixFmt != nil}
  /// Clears the value of `pixFmt`. Subsequent reads from it will return its default value.
  mutating func clearPixFmt() {self._pixFmt = nil}

  var framerate: Float {
    get {return _framerate ?? 0}
    set {_framerate = newValue}
  }
  /// Returns true if `framerate` has been explicitly set.
  var hasFramerate: Bool {return self._framerate != nil}
  /// Clears the value of `framerate`. Subsequent reads from it will return its default value.
  mutating func clearFramerate() {self._framerate = nil}

  var playoutFrames: Int32 {
    get {return _playoutFrames ?? 0}
    set {_playoutFrames = newValue}
  }
  /// Returns true if `playoutFrames` has been explicitly set.
  var hasPlayoutFrames: Bool {return self._playoutFrames != nil}
  /// Clears the value of `playoutFrames`. Subsequent reads from it will return its default value.
  mutating func clearPlayoutFrames() {self._playoutFrames = nil}

  var pursuit: Int32 {
    get {return _pursuit ?? 0}
    set {_pursuit = newValue}
  }
  /// Returns true if `pursuit` has been explicitly set.
  var hasPursuit: Bool {return self._pursuit != nil}
  /// Clears the value of `pursuit`. Subsequent reads from it will return its default value.
  mutating func clearPursuit() {self._pursuit = nil}

  var realtime: Bool {
    get {return _realtime ?? false}
    set {_realtime = newValue}
  }
  /// Returns true if `realtime` has been explicitly set.
  var hasRealtime: Bool {return self._realtime != nil}
  /// Clears the value of `realtime`. Subsequent reads from it will return its default value.
  mutating func clearRealtime() {self._realtime = nil}

  var stoptimeSec: Float {
    get {return _stoptimeSec ?? 0}
    set {_stoptimeSec = newValue}
  }
  /// Returns true if `stoptimeSec` has been explicitly set.
  var hasStoptimeSec: Bool {return self._stoptimeSec != nil}
  /// Clears the value of `stoptimeSec`. Subsequent reads from it will return its default value.
  mutating func clearStoptimeSec() {self._stoptimeSec = nil}

  var show: Bool {
    get {return _show ?? false}
    set {_show = newValue}
  }
  /// Returns true if `show` has been explicitly set.
  var hasShow: Bool {return self._show != nil}
  /// Clears the value of `show`. Subsequent reads from it will return its default value.
  mutating func clearShow() {self._show = nil}

  var deviceDecode: Bool {
    get {return _deviceDecode ?? false}
    set {_deviceDecode = newValue}
  }
  /// Returns true if `deviceDecode` has been explicitly set.
  var hasDeviceDecode: Bool {return self._deviceDecode != nil}
  /// Clears the value of `deviceDecode`. Subsequent reads from it will return its default value.
  mutating func clearDeviceDecode() {self._deviceDecode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filepath: String? = nil
  fileprivate var _resolution: String? = nil
  fileprivate var _pixFmt: PixFmt? = nil
  fileprivate var _framerate: Float? = nil
  fileprivate var _playoutFrames: Int32? = nil
  fileprivate var _pursuit: Int32? = nil
  fileprivate var _realtime: Bool? = nil
  fileprivate var _stoptimeSec: Float? = nil
  fileprivate var _show: Bool? = nil
  fileprivate var _deviceDecode: Bool? = nil
}

struct Configure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parameter: [Parameter] {
    get {return _storage._parameter}
    set {_uniqueStorage()._parameter = newValue}
  }

  /// known shortcuts
  var codec: String {
    get {return _storage._codec ?? String()}
    set {_uniqueStorage()._codec = newValue}
  }
  /// Returns true if `codec` has been explicitly set.
  var hasCodec: Bool {return _storage._codec != nil}
  /// Clears the value of `codec`. Subsequent reads from it will return its default value.
  mutating func clearCodec() {_uniqueStorage()._codec = nil}

  var encode: Bool {
    get {return _storage._encode ?? false}
    set {_uniqueStorage()._encode = newValue}
  }
  /// Returns true if `encode` has been explicitly set.
  var hasEncode: Bool {return _storage._encode != nil}
  /// Clears the value of `encode`. Subsequent reads from it will return its default value.
  mutating func clearEncode() {_uniqueStorage()._encode = nil}

  var surface: Bool {
    get {return _storage._surface ?? false}
    set {_uniqueStorage()._surface = newValue}
  }
  /// Returns true if `surface` has been explicitly set.
  var hasSurface: Bool {return _storage._surface != nil}
  /// Clears the value of `surface`. Subsequent reads from it will return its default value.
  mutating func clearSurface() {_uniqueStorage()._surface = nil}

  var mime: String {
    get {return _storage._mime ?? String()}
    set {_uniqueStorage()._mime = newValue}
  }
  /// Returns true if `mime` has been explicitly set.
  var hasMime: Bool {return _storage._mime != nil}
  /// Clears the value of `mime`. Subsequent reads from it will return its default value.
  mutating func clearMime() {_uniqueStorage()._mime = nil}

  var bitrate: String {
    get {return _storage._bitrate ?? String()}
    set {_uniqueStorage()._bitrate = newValue}
  }
  /// Returns true if `bitrate` has been explicitly set.
  var hasBitrate: Bool {return _storage._bitrate != nil}
  /// Clears the value of `bitrate`. Subsequent reads from it will return its default value.
  mutating func clearBitrate() {_uniqueStorage()._bitrate = nil}

  var bitrateMode: Configure.BitrateMode {
    get {return _storage._bitrateMode ?? .cq}
    set {_uniqueStorage()._bitrateMode = newValue}
  }
  /// Returns true if `bitrateMode` has been explicitly set.
  var hasBitrateMode: Bool {return _storage._bitrateMode != nil}
  /// Clears the value of `bitrateMode`. Subsequent reads from it will return its default value.
  mutating func clearBitrateMode() {_uniqueStorage()._bitrateMode = nil}

  var durationUs: UInt64 {
    get {return _storage._durationUs ?? 0}
    set {_uniqueStorage()._durationUs = newValue}
  }
  /// Returns true if `durationUs` has been explicitly set.
  var hasDurationUs: Bool {return _storage._durationUs != nil}
  /// Clears the value of `durationUs`. Subsequent reads from it will return its default value.
  mutating func clearDurationUs() {_uniqueStorage()._durationUs = nil}

  var resolution: String {
    get {return _storage._resolution ?? String()}
    set {_uniqueStorage()._resolution = newValue}
  }
  /// Returns true if `resolution` has been explicitly set.
  var hasResolution: Bool {return _storage._resolution != nil}
  /// Clears the value of `resolution`. Subsequent reads from it will return its default value.
  mutating func clearResolution() {_uniqueStorage()._resolution = nil}

  var colorFormat: Int32 {
    get {return _storage._colorFormat ?? 0}
    set {_uniqueStorage()._colorFormat = newValue}
  }
  /// Returns true if `colorFormat` has been explicitly set.
  var hasColorFormat: Bool {return _storage._colorFormat != nil}
  /// Clears the value of `colorFormat`. Subsequent reads from it will return its default value.
  mutating func clearColorFormat() {_uniqueStorage()._colorFormat = nil}

  var colorStandard: Configure.ColorStandard {
    get {return _storage._colorStandard ?? .bt601Pal}
    set {_uniqueStorage()._colorStandard = newValue}
  }
  /// Returns true if `colorStandard` has been explicitly set.
  var hasColorStandard: Bool {return _storage._colorStandard != nil}
  /// Clears the value of `colorStandard`. Subsequent reads from it will return its default value.
  mutating func clearColorStandard() {_uniqueStorage()._colorStandard = nil}

  var colorRange: Configure.ColorRange {
    get {return _storage._colorRange ?? .full}
    set {_uniqueStorage()._colorRange = newValue}
  }
  /// Returns true if `colorRange` has been explicitly set.
  var hasColorRange: Bool {return _storage._colorRange != nil}
  /// Clears the value of `colorRange`. Subsequent reads from it will return its default value.
  mutating func clearColorRange() {_uniqueStorage()._colorRange = nil}

  var colorTransfer: Configure.ColorTransfer {
    get {return _storage._colorTransfer ?? .linear}
    set {_uniqueStorage()._colorTransfer = newValue}
  }
  /// Returns true if `colorTransfer` has been explicitly set.
  var hasColorTransfer: Bool {return _storage._colorTransfer != nil}
  /// Clears the value of `colorTransfer`. Subsequent reads from it will return its default value.
  mutating func clearColorTransfer() {_uniqueStorage()._colorTransfer = nil}

  var colorTransferRequest: String {
    get {return _storage._colorTransferRequest ?? String()}
    set {_uniqueStorage()._colorTransferRequest = newValue}
  }
  /// Returns true if `colorTransferRequest` has been explicitly set.
  var hasColorTransferRequest: Bool {return _storage._colorTransferRequest != nil}
  /// Clears the value of `colorTransferRequest`. Subsequent reads from it will return its default value.
  mutating func clearColorTransferRequest() {_uniqueStorage()._colorTransferRequest = nil}

  var framerate: Float {
    get {return _storage._framerate ?? 0}
    set {_uniqueStorage()._framerate = newValue}
  }
  /// Returns true if `framerate` has been explicitly set.
  var hasFramerate: Bool {return _storage._framerate != nil}
  /// Clears the value of `framerate`. Subsequent reads from it will return its default value.
  mutating func clearFramerate() {_uniqueStorage()._framerate = nil}

  var iFrameInterval: Int32 {
    get {return _storage._iFrameInterval ?? 0}
    set {_uniqueStorage()._iFrameInterval = newValue}
  }
  /// Returns true if `iFrameInterval` has been explicitly set.
  var hasIFrameInterval: Bool {return _storage._iFrameInterval != nil}
  /// Clears the value of `iFrameInterval`. Subsequent reads from it will return its default value.
  mutating func clearIFrameInterval() {_uniqueStorage()._iFrameInterval = nil}

  var intraRefreshPeriod: Int32 {
    get {return _storage._intraRefreshPeriod ?? 0}
    set {_uniqueStorage()._intraRefreshPeriod = newValue}
  }
  /// Returns true if `intraRefreshPeriod` has been explicitly set.
  var hasIntraRefreshPeriod: Bool {return _storage._intraRefreshPeriod != nil}
  /// Clears the value of `intraRefreshPeriod`. Subsequent reads from it will return its default value.
  mutating func clearIntraRefreshPeriod() {_uniqueStorage()._intraRefreshPeriod = nil}

  var latency: Int32 {
    get {return _storage._latency ?? 0}
    set {_uniqueStorage()._latency = newValue}
  }
  /// Returns true if `latency` has been explicitly set.
  var hasLatency: Bool {return _storage._latency != nil}
  /// Clears the value of `latency`. Subsequent reads from it will return its default value.
  mutating func clearLatency() {_uniqueStorage()._latency = nil}

  var repeatPreviousFrameAfter: Int64 {
    get {return _storage._repeatPreviousFrameAfter ?? 0}
    set {_uniqueStorage()._repeatPreviousFrameAfter = newValue}
  }
  /// Returns true if `repeatPreviousFrameAfter` has been explicitly set.
  var hasRepeatPreviousFrameAfter: Bool {return _storage._repeatPreviousFrameAfter != nil}
  /// Clears the value of `repeatPreviousFrameAfter`. Subsequent reads from it will return its default value.
  mutating func clearRepeatPreviousFrameAfter() {_uniqueStorage()._repeatPreviousFrameAfter = nil}

  var tsSchema: String {
    get {return _storage._tsSchema ?? String()}
    set {_uniqueStorage()._tsSchema = newValue}
  }
  /// Returns true if `tsSchema` has been explicitly set.
  var hasTsSchema: Bool {return _storage._tsSchema != nil}
  /// Clears the value of `tsSchema`. Subsequent reads from it will return its default value.
  mutating func clearTsSchema() {_uniqueStorage()._tsSchema = nil}

  var quality: Int32 {
    get {return _storage._quality ?? 0}
    set {_uniqueStorage()._quality = newValue}
  }
  /// Returns true if `quality` has been explicitly set.
  var hasQuality: Bool {return _storage._quality != nil}
  /// Clears the value of `quality`. Subsequent reads from it will return its default value.
  mutating func clearQuality() {_uniqueStorage()._quality = nil}

  var complexity: Int32 {
    get {return _storage._complexity ?? 0}
    set {_uniqueStorage()._complexity = newValue}
  }
  /// Returns true if `complexity` has been explicitly set.
  var hasComplexity: Bool {return _storage._complexity != nil}
  /// Clears the value of `complexity`. Subsequent reads from it will return its default value.
  mutating func clearComplexity() {_uniqueStorage()._complexity = nil}

  var decodeDump: Bool {
    get {return _storage._decodeDump ?? false}
    set {_uniqueStorage()._decodeDump = newValue}
  }
  /// Returns true if `decodeDump` has been explicitly set.
  var hasDecodeDump: Bool {return _storage._decodeDump != nil}
  /// Clears the value of `decodeDump`. Subsequent reads from it will return its default value.
  mutating func clearDecodeDump() {_uniqueStorage()._decodeDump = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum BitrateMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case cq // = 0
    case vbr // = 1
    case cbr // = 2
    case cbrFd // = 3

    init() {
      self = .cq
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cq
      case 1: self = .vbr
      case 2: self = .cbr
      case 3: self = .cbrFd
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .cq: return 0
      case .vbr: return 1
      case .cbr: return 2
      case .cbrFd: return 3
      }
    }

  }

  enum ColorStandard: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case bt601Pal // = 2
    case bt601Ntsc // = 4
    case bt709 // = 1
    case bt2020 // = 6

    init() {
      self = .bt601Pal
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .bt709
      case 2: self = .bt601Pal
      case 4: self = .bt601Ntsc
      case 6: self = .bt2020
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .bt709: return 1
      case .bt601Pal: return 2
      case .bt601Ntsc: return 4
      case .bt2020: return 6
      }
    }

  }

  enum ColorRange: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case full // = 1
    case limited // = 2

    init() {
      self = .full
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .full
      case 2: self = .limited
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .full: return 1
      case .limited: return 2
      }
    }

  }

  enum ColorTransfer: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case linear // = 1
    case sdrVideo // = 3
    case st2084 // = 6
    case hlg // = 7

    init() {
      self = .linear
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .linear
      case 3: self = .sdrVideo
      case 6: self = .st2084
      case 7: self = .hlg
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .linear: return 1
      case .sdrVideo: return 3
      case .st2084: return 6
      case .hlg: return 7
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Configure.BitrateMode: CaseIterable {
  // Support synthesized by the compiler.
}

extension Configure.ColorStandard: CaseIterable {
  // Support synthesized by the compiler.
}

extension Configure.ColorRange: CaseIterable {
  // Support synthesized by the compiler.
}

extension Configure.ColorTransfer: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Runtime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parameter: [Parameter] = []

  var videoBitrate: [Runtime.VideoBitrateParameter] = []

  var drop: [Int64] = []

  var dynamicFramerate: [Runtime.DynamicFramerateParameter] = []

  var requestSync: [Int64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// known shortcuts
  struct VideoBitrateParameter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var framenum: Int64 {
      get {return _framenum ?? 0}
      set {_framenum = newValue}
    }
    /// Returns true if `framenum` has been explicitly set.
    var hasFramenum: Bool {return self._framenum != nil}
    /// Clears the value of `framenum`. Subsequent reads from it will return its default value.
    mutating func clearFramenum() {self._framenum = nil}

    ///can be just a figure in bps or with prefix, k or M
    var bitrate: String {
      get {return _bitrate ?? String()}
      set {_bitrate = newValue}
    }
    /// Returns true if `bitrate` has been explicitly set.
    var hasBitrate: Bool {return self._bitrate != nil}
    /// Clears the value of `bitrate`. Subsequent reads from it will return its default value.
    mutating func clearBitrate() {self._bitrate = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _framenum: Int64? = nil
    fileprivate var _bitrate: String? = nil
  }

  struct DynamicFramerateParameter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var framenum: Int64 {
      get {return _framenum ?? 0}
      set {_framenum = newValue}
    }
    /// Returns true if `framenum` has been explicitly set.
    var hasFramenum: Bool {return self._framenum != nil}
    /// Clears the value of `framenum`. Subsequent reads from it will return its default value.
    mutating func clearFramenum() {self._framenum = nil}

    var framerate: Float {
      get {return _framerate ?? 0}
      set {_framerate = newValue}
    }
    /// Returns true if `framerate` has been explicitly set.
    var hasFramerate: Bool {return self._framerate != nil}
    /// Clears the value of `framerate`. Subsequent reads from it will return its default value.
    mutating func clearFramerate() {self._framerate = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _framenum: Int64? = nil
    fileprivate var _framerate: Float? = nil
  }

  init() {}
}

struct DecoderConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parameter: [Parameter] = []

  var codec: String {
    get {return _codec ?? String()}
    set {_codec = newValue}
  }
  /// Returns true if `codec` has been explicitly set.
  var hasCodec: Bool {return self._codec != nil}
  /// Clears the value of `codec`. Subsequent reads from it will return its default value.
  mutating func clearCodec() {self._codec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _codec: String? = nil
}

struct DecoderRuntime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parameter: [Parameter] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Parallel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var test: [Test] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Serial {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var test: [Test] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Test {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var common: Common {
    get {return _storage._common ?? Common()}
    set {_uniqueStorage()._common = newValue}
  }
  /// Returns true if `common` has been explicitly set.
  var hasCommon: Bool {return _storage._common != nil}
  /// Clears the value of `common`. Subsequent reads from it will return its default value.
  mutating func clearCommon() {_uniqueStorage()._common = nil}

  var input: Input {
    get {return _storage._input ?? Input()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {_uniqueStorage()._input = nil}

  var configure: Configure {
    get {return _storage._configure ?? Configure()}
    set {_uniqueStorage()._configure = newValue}
  }
  /// Returns true if `configure` has been explicitly set.
  var hasConfigure: Bool {return _storage._configure != nil}
  /// Clears the value of `configure`. Subsequent reads from it will return its default value.
  mutating func clearConfigure() {_uniqueStorage()._configure = nil}

  var runtime: Runtime {
    get {return _storage._runtime ?? Runtime()}
    set {_uniqueStorage()._runtime = newValue}
  }
  /// Returns true if `runtime` has been explicitly set.
  var hasRuntime: Bool {return _storage._runtime != nil}
  /// Clears the value of `runtime`. Subsequent reads from it will return its default value.
  mutating func clearRuntime() {_uniqueStorage()._runtime = nil}

  var decoderConfigure: DecoderConfigure {
    get {return _storage._decoderConfigure ?? DecoderConfigure()}
    set {_uniqueStorage()._decoderConfigure = newValue}
  }
  /// Returns true if `decoderConfigure` has been explicitly set.
  var hasDecoderConfigure: Bool {return _storage._decoderConfigure != nil}
  /// Clears the value of `decoderConfigure`. Subsequent reads from it will return its default value.
  mutating func clearDecoderConfigure() {_uniqueStorage()._decoderConfigure = nil}

  var decoderRuntime: DecoderRuntime {
    get {return _storage._decoderRuntime ?? DecoderRuntime()}
    set {_uniqueStorage()._decoderRuntime = newValue}
  }
  /// Returns true if `decoderRuntime` has been explicitly set.
  var hasDecoderRuntime: Bool {return _storage._decoderRuntime != nil}
  /// Clears the value of `decoderRuntime`. Subsequent reads from it will return its default value.
  mutating func clearDecoderRuntime() {_uniqueStorage()._decoderRuntime = nil}

  var parallel: Parallel {
    get {return _storage._parallel ?? Parallel()}
    set {_uniqueStorage()._parallel = newValue}
  }
  /// Returns true if `parallel` has been explicitly set.
  var hasParallel: Bool {return _storage._parallel != nil}
  /// Clears the value of `parallel`. Subsequent reads from it will return its default value.
  mutating func clearParallel() {_uniqueStorage()._parallel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TestSuite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tests are serial unless included in another test as parallel
  var test: [Test] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension DataValueType: @unchecked Sendable {}
extension PixFmt: @unchecked Sendable {}
extension Common: @unchecked Sendable {}
extension Parameter: @unchecked Sendable {}
extension Input: @unchecked Sendable {}
extension Configure: @unchecked Sendable {}
extension Configure.BitrateMode: @unchecked Sendable {}
extension Configure.ColorStandard: @unchecked Sendable {}
extension Configure.ColorRange: @unchecked Sendable {}
extension Configure.ColorTransfer: @unchecked Sendable {}
extension Runtime: @unchecked Sendable {}
extension Runtime.VideoBitrateParameter: @unchecked Sendable {}
extension Runtime.DynamicFramerateParameter: @unchecked Sendable {}
extension DecoderConfigure: @unchecked Sendable {}
extension DecoderRuntime: @unchecked Sendable {}
extension Parallel: @unchecked Sendable {}
extension Serial: @unchecked Sendable {}
extension Test: @unchecked Sendable {}
extension TestSuite: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension DataValueType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "stringType"),
    1: .same(proto: "intType"),
    2: .same(proto: "floatType"),
    3: .same(proto: "longType"),
  ]
}

extension PixFmt: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "yuv420p"),
    1: .same(proto: "yvu420p"),
    2: .same(proto: "nv12"),
    3: .same(proto: "nv21"),
    4: .same(proto: "rgba"),
    54: .same(proto: "p010le"),
  ]
}

extension Common: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "description"),
    3: .same(proto: "operation"),
    4: .same(proto: "start"),
    5: .standard(proto: "output_filename"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._operation) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._start) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._outputFilename) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._operation {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._start {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._outputFilename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Common, rhs: Common) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._operation != rhs._operation {return false}
    if lhs._start != rhs._start {return false}
    if lhs._outputFilename != rhs._outputFilename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Parameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Parameter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "type"),
    3: .same(proto: "value"),
    4: .same(proto: "framenum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._framenum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._framenum {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Parameter, rhs: Parameter) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._type != rhs._type {return false}
    if lhs._value != rhs._value {return false}
    if lhs._framenum != rhs._framenum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Input"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filepath"),
    2: .same(proto: "resolution"),
    3: .standard(proto: "pix_fmt"),
    4: .same(proto: "framerate"),
    5: .standard(proto: "playout_frames"),
    6: .same(proto: "pursuit"),
    7: .same(proto: "realtime"),
    8: .standard(proto: "stoptime_sec"),
    9: .same(proto: "show"),
    10: .standard(proto: "device_decode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._filepath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._resolution) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._pixFmt) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._framerate) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._playoutFrames) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._pursuit) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._realtime) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self._stoptimeSec) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._show) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._deviceDecode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._filepath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resolution {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pixFmt {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._framerate {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._playoutFrames {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._pursuit {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._realtime {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._stoptimeSec {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._show {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._deviceDecode {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Input, rhs: Input) -> Bool {
    if lhs._filepath != rhs._filepath {return false}
    if lhs._resolution != rhs._resolution {return false}
    if lhs._pixFmt != rhs._pixFmt {return false}
    if lhs._framerate != rhs._framerate {return false}
    if lhs._playoutFrames != rhs._playoutFrames {return false}
    if lhs._pursuit != rhs._pursuit {return false}
    if lhs._realtime != rhs._realtime {return false}
    if lhs._stoptimeSec != rhs._stoptimeSec {return false}
    if lhs._show != rhs._show {return false}
    if lhs._deviceDecode != rhs._deviceDecode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Configure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Configure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameter"),
    2: .same(proto: "codec"),
    3: .same(proto: "encode"),
    4: .same(proto: "surface"),
    5: .same(proto: "mime"),
    6: .same(proto: "bitrate"),
    7: .standard(proto: "bitrate_mode"),
    8: .same(proto: "durationUs"),
    9: .same(proto: "resolution"),
    10: .standard(proto: "color_format"),
    11: .standard(proto: "color_standard"),
    12: .standard(proto: "color_range"),
    13: .standard(proto: "color_transfer"),
    14: .standard(proto: "color_transfer_request"),
    15: .same(proto: "framerate"),
    16: .standard(proto: "i_frame_interval"),
    17: .standard(proto: "intra_refresh_period"),
    18: .same(proto: "latency"),
    19: .standard(proto: "repeat_previous_frame_after"),
    20: .standard(proto: "ts_schema"),
    21: .same(proto: "quality"),
    22: .same(proto: "complexity"),
    23: .standard(proto: "decode_dump"),
  ]

  fileprivate class _StorageClass {
    var _parameter: [Parameter] = []
    var _codec: String? = nil
    var _encode: Bool? = nil
    var _surface: Bool? = nil
    var _mime: String? = nil
    var _bitrate: String? = nil
    var _bitrateMode: Configure.BitrateMode? = nil
    var _durationUs: UInt64? = nil
    var _resolution: String? = nil
    var _colorFormat: Int32? = nil
    var _colorStandard: Configure.ColorStandard? = nil
    var _colorRange: Configure.ColorRange? = nil
    var _colorTransfer: Configure.ColorTransfer? = nil
    var _colorTransferRequest: String? = nil
    var _framerate: Float? = nil
    var _iFrameInterval: Int32? = nil
    var _intraRefreshPeriod: Int32? = nil
    var _latency: Int32? = nil
    var _repeatPreviousFrameAfter: Int64? = nil
    var _tsSchema: String? = nil
    var _quality: Int32? = nil
    var _complexity: Int32? = nil
    var _decodeDump: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parameter = source._parameter
      _codec = source._codec
      _encode = source._encode
      _surface = source._surface
      _mime = source._mime
      _bitrate = source._bitrate
      _bitrateMode = source._bitrateMode
      _durationUs = source._durationUs
      _resolution = source._resolution
      _colorFormat = source._colorFormat
      _colorStandard = source._colorStandard
      _colorRange = source._colorRange
      _colorTransfer = source._colorTransfer
      _colorTransferRequest = source._colorTransferRequest
      _framerate = source._framerate
      _iFrameInterval = source._iFrameInterval
      _intraRefreshPeriod = source._intraRefreshPeriod
      _latency = source._latency
      _repeatPreviousFrameAfter = source._repeatPreviousFrameAfter
      _tsSchema = source._tsSchema
      _quality = source._quality
      _complexity = source._complexity
      _decodeDump = source._decodeDump
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._parameter) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._codec) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._encode) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._surface) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._mime) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._bitrate) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._bitrateMode) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._durationUs) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._resolution) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._colorFormat) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._colorStandard) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._colorRange) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._colorTransfer) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._colorTransferRequest) }()
        case 15: try { try decoder.decodeSingularFloatField(value: &_storage._framerate) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._iFrameInterval) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._intraRefreshPeriod) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._latency) }()
        case 19: try { try decoder.decodeSingularInt64Field(value: &_storage._repeatPreviousFrameAfter) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._tsSchema) }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._quality) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._complexity) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._decodeDump) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._parameter.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._parameter, fieldNumber: 1)
      }
      try { if let v = _storage._codec {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._encode {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._surface {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._mime {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._bitrate {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._bitrateMode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._durationUs {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._resolution {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._colorFormat {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._colorStandard {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._colorRange {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._colorTransfer {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._colorTransferRequest {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._framerate {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._iFrameInterval {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._intraRefreshPeriod {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._latency {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._repeatPreviousFrameAfter {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._tsSchema {
        try visitor.visitSingularStringField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._quality {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._complexity {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._decodeDump {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 23)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Configure, rhs: Configure) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parameter != rhs_storage._parameter {return false}
        if _storage._codec != rhs_storage._codec {return false}
        if _storage._encode != rhs_storage._encode {return false}
        if _storage._surface != rhs_storage._surface {return false}
        if _storage._mime != rhs_storage._mime {return false}
        if _storage._bitrate != rhs_storage._bitrate {return false}
        if _storage._bitrateMode != rhs_storage._bitrateMode {return false}
        if _storage._durationUs != rhs_storage._durationUs {return false}
        if _storage._resolution != rhs_storage._resolution {return false}
        if _storage._colorFormat != rhs_storage._colorFormat {return false}
        if _storage._colorStandard != rhs_storage._colorStandard {return false}
        if _storage._colorRange != rhs_storage._colorRange {return false}
        if _storage._colorTransfer != rhs_storage._colorTransfer {return false}
        if _storage._colorTransferRequest != rhs_storage._colorTransferRequest {return false}
        if _storage._framerate != rhs_storage._framerate {return false}
        if _storage._iFrameInterval != rhs_storage._iFrameInterval {return false}
        if _storage._intraRefreshPeriod != rhs_storage._intraRefreshPeriod {return false}
        if _storage._latency != rhs_storage._latency {return false}
        if _storage._repeatPreviousFrameAfter != rhs_storage._repeatPreviousFrameAfter {return false}
        if _storage._tsSchema != rhs_storage._tsSchema {return false}
        if _storage._quality != rhs_storage._quality {return false}
        if _storage._complexity != rhs_storage._complexity {return false}
        if _storage._decodeDump != rhs_storage._decodeDump {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Configure.BitrateMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "cq"),
    1: .same(proto: "vbr"),
    2: .same(proto: "cbr"),
    3: .same(proto: "cbr_fd"),
  ]
}

extension Configure.ColorStandard: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bt709"),
    2: .same(proto: "bt601_pal"),
    4: .same(proto: "bt601_ntsc"),
    6: .same(proto: "bt2020"),
  ]
}

extension Configure.ColorRange: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "full"),
    2: .same(proto: "limited"),
  ]
}

extension Configure.ColorTransfer: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "linear"),
    3: .same(proto: "sdr_video"),
    6: .same(proto: "st2084"),
    7: .same(proto: "hlg"),
  ]
}

extension Runtime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Runtime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameter"),
    2: .standard(proto: "video_bitrate"),
    3: .same(proto: "drop"),
    4: .standard(proto: "dynamic_framerate"),
    5: .standard(proto: "request_sync"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.parameter) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.videoBitrate) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.drop) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.dynamicFramerate) }()
      case 5: try { try decoder.decodeRepeatedInt64Field(value: &self.requestSync) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parameter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameter, fieldNumber: 1)
    }
    if !self.videoBitrate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.videoBitrate, fieldNumber: 2)
    }
    if !self.drop.isEmpty {
      try visitor.visitRepeatedInt64Field(value: self.drop, fieldNumber: 3)
    }
    if !self.dynamicFramerate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dynamicFramerate, fieldNumber: 4)
    }
    if !self.requestSync.isEmpty {
      try visitor.visitRepeatedInt64Field(value: self.requestSync, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime, rhs: Runtime) -> Bool {
    if lhs.parameter != rhs.parameter {return false}
    if lhs.videoBitrate != rhs.videoBitrate {return false}
    if lhs.drop != rhs.drop {return false}
    if lhs.dynamicFramerate != rhs.dynamicFramerate {return false}
    if lhs.requestSync != rhs.requestSync {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime.VideoBitrateParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Runtime.protoMessageName + ".VideoBitrateParameter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "framenum"),
    2: .same(proto: "bitrate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._framenum) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._bitrate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._framenum {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._bitrate {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime.VideoBitrateParameter, rhs: Runtime.VideoBitrateParameter) -> Bool {
    if lhs._framenum != rhs._framenum {return false}
    if lhs._bitrate != rhs._bitrate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime.DynamicFramerateParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Runtime.protoMessageName + ".DynamicFramerateParameter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "framenum"),
    2: .same(proto: "framerate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._framenum) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._framerate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._framenum {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._framerate {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime.DynamicFramerateParameter, rhs: Runtime.DynamicFramerateParameter) -> Bool {
    if lhs._framenum != rhs._framenum {return false}
    if lhs._framerate != rhs._framerate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DecoderConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DecoderConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameter"),
    2: .same(proto: "codec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.parameter) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._codec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parameter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameter, fieldNumber: 1)
    }
    try { if let v = self._codec {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DecoderConfigure, rhs: DecoderConfigure) -> Bool {
    if lhs.parameter != rhs.parameter {return false}
    if lhs._codec != rhs._codec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DecoderRuntime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DecoderRuntime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.parameter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parameter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameter, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DecoderRuntime, rhs: DecoderRuntime) -> Bool {
    if lhs.parameter != rhs.parameter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Parallel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Parallel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "test"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.test) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.test.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.test, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Parallel, rhs: Parallel) -> Bool {
    if lhs.test != rhs.test {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Serial: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Serial"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "test"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.test) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.test.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.test, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Serial, rhs: Serial) -> Bool {
    if lhs.test != rhs.test {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "common"),
    2: .same(proto: "input"),
    3: .same(proto: "configure"),
    4: .same(proto: "runtime"),
    5: .standard(proto: "decoder_configure"),
    6: .standard(proto: "decoder_runtime"),
    7: .same(proto: "parallel"),
  ]

  fileprivate class _StorageClass {
    var _common: Common? = nil
    var _input: Input? = nil
    var _configure: Configure? = nil
    var _runtime: Runtime? = nil
    var _decoderConfigure: DecoderConfigure? = nil
    var _decoderRuntime: DecoderRuntime? = nil
    var _parallel: Parallel? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _common = source._common
      _input = source._input
      _configure = source._configure
      _runtime = source._runtime
      _decoderConfigure = source._decoderConfigure
      _decoderRuntime = source._decoderRuntime
      _parallel = source._parallel
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._common) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._configure) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._runtime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._decoderConfigure) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._decoderRuntime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._parallel) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._common {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._configure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._runtime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._decoderConfigure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._decoderRuntime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._parallel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test, rhs: Test) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._common != rhs_storage._common {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._configure != rhs_storage._configure {return false}
        if _storage._runtime != rhs_storage._runtime {return false}
        if _storage._decoderConfigure != rhs_storage._decoderConfigure {return false}
        if _storage._decoderRuntime != rhs_storage._decoderRuntime {return false}
        if _storage._parallel != rhs_storage._parallel {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TestSuite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TestSuite"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "test"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.test) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.test.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.test, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TestSuite, rhs: TestSuite) -> Bool {
    if lhs.test != rhs.test {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
